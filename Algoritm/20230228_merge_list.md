:calendar: 2023. 02. 28. Tue.

# :memo: 삽입정렬(Insertion Sort) 2. by. Python
## 두 개의 정렬된 배열(리스트) 병합

1. 제한사항
   1. 두 개의 배열 (nums1, nums2)의 크기는 각각 n개, n개의 요소로 초기화 되어 있다
   2. nums1은 nums1, nums2 배열을 병합시키에 충분한 크기로 할당이 되어 있다.
   3. 주어진 두 배열은 모두 정렬이 되어 있다. (이진 탐색 가능)
   4. 병합이 된 후에도 정렬된 상태로 유지해야 한다. (이때 중복값이 있을 수 있다)
2. 아이디어
   1. nums1의 인덱스 포인터 `i` = `len(nums1) - 1`
   2. nums2의 인덱스 포인터 `j` = `len(nums2) - 1`
   3. 삽입을 위한 포인터 `k` = `len(nums1 + nums2) - 1`
   4. 현재 `i`와 `j` 값을 비교하여 큰 쪽의 값을 `k`의 위치에 추가
      1. 이렇게 되면 `k` 값은 줄어듦
      2. 비교하여 큰 쪽의 인덱스가 `k`에 추가되었으므로 큰 쪽의 인덱스는 1이 감소함
   5. `i`, `j` 중 하나라도 0보다 작아지면 비교를 중지함
   6. `j`가 아직 0보다 크다면 현재 삽입된 후의 포인터인 `k` 값을 감소시키면서 nums1에 삽입
3. 주의할 점
   1. 값에 의한 호출(Call by value)와 참조에 의한 호출은 다르다. 이 두 가지 개념의 차이를 명확하게 이해한 후, 내장 함수를 활용할 줄 알아야 한다.
   2. 파이썬의 리스트를 정수형 / 부동 소수형 / 문자열 변수 처리하듯 사용하면(일반 대입) '값에 의한 참조'로 바뀌어 원하는 결과가 나오지 않을 수 있다.
   3. 이럴 때 슬라이스 대입을 이용한다.

```python

def merge(nums1: [], nums2: []) -> None:
  m = len(nums1)
  n = len(nums2)
  i = m - 1
  j = n - 1
  k = m + n - 1

  while i >= 0 and j >= 0:
    if nums1[i] < nums2[j]:
      nums1[k] = nums2[i]
      j -= 1
    else:
      nums1[k] = nums1[i]
      i -= 1
    
    k -= 1
  
  while j >= 0:
    nums1[k] = nums2[j]
    k -= 1
    j -= 1
```